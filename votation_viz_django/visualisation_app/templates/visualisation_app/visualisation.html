<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Votation suisse</title>
  <meta name="author" content="Baptiste Raeamy">
  <meta name="description" content="description here">
  <meta name="keywords" content="keywords,here">

  {% load static %}
  <link rel="stylesheet" type="text/css" href="{% static 'visualisation_app/stylesheet.css' %}" />
  <link rel="stylesheet" href="{% static 'visualisation_app/d3.slider.css' %}" />


  </head>
  <body>
    <script src="//d3js.org/d3.v3.min.js"></script>
    <script src="//d3js.org/topojson.v1.min.js"></script>
    <script src="http://d3js.org/queue.v1.min.js"></script>
    <!--script src="lib/d3-slider/d3.slider.js"></script-->
    <script src="{% static 'visualisation_app/d3.slider.js' %}"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
    <h2>Slider</h2>
    <span id="sliderText">0</span></h2>

    <div id="slider"></div>


    <script>
    var m_width = 1000, //not sure about this variable
        width = 960,
        height = 500;

    var path = d3.geo.path()
        .projection(null);

    var svg = d3.select("body").append("svg")
        .attr("preserveAspectRatio", "xMidYMid")
        .attr("viewBox", "0 0 " + width + " " + height)
        .attr("width", m_width)
        .attr("height", m_width * height / width);


    var zoom = d3.behavior.zoom()
        .translate([0, 0])
        .scale(1)
        .scaleExtent([1, 8])

    var g = svg.append("g");

    svg.append("rect")
        .attr("class", "overlay")
        .attr("width", width)
        .attr("height", height)

    svg
        .call(zoom) // delete this line to disable free zooming
        .call(zoom.event);

    var dataMap = d3.map();
    var dataCantonMap = d3.map();

    var min = 0
    var max = 50
    var colorYes =d3.scale.linear().domain([50,100]).range(["#ebfaeb","#33cc33"]);
    var colorNo =d3.scale.linear().domain([50,0]).range(["#ffe6e6","#ff0000"]);

    var topo = ""

    init()

    function init() {
      loadData()
      //setSlider()
      setZoom()

    }


    function loadData() {
      queue()
        .defer(d3.json, "{% url "get_ch_json" %}")
        .defer(d3.csv, "{% url "get_nucleaire_csv" %}", function(d) { dataMap.set(d.id, d.data); })
        .defer(d3.csv, "{% url "get_nucleairecanton_csv" %}", function(d) { dataCantonMap.set(d.id, d.data); })

        .await(display);
    }



    function display(error, ch) {
      if(error) throw error;
      topo = ch
      var cantons = topojson.feature(ch, ch.objects.cantons);
      setMunicipalities(ch)
      //setCantons(ch)
      setTextInCanton(cantons)
      setLake(ch)


    }

    function setLake(ch) {
      g.append("g")
          .attr("class", "feature lake")
        .selectAll("path")
          .data(topojson.feature(ch, ch.objects.lakes).features)
        .enter().append("path")
          .attr("d", path)
        .append("title")
          .text(function(d) { return d.id; });

      g.append("path")
        .datum(topojson.mesh(ch, ch.objects.lakes, function(a, b) { return a !== b; }))
        .attr("class", "lake-boundaries")
        .attr("d", path);

    }

    function setMunicipalities(ch) {
      //municipalities
      g.append("g")
          .attr("class", "feature municipality")
        .selectAll("path")
          .data(topojson.feature(ch, ch.objects.municipalities).features)
        .enter().append("path")
          .attr("fill", function(d) {
              return getColor(d, dataMap)
            })
          .attr("d", path)
        .append("title")
          .text(function(d) { return d.id; });

      g.append("path")
        .datum(topojson.mesh(ch, ch.objects.municipalities, function(a, b) { return a !== b; }))
        .attr("class", "municipality-boundaries")
        .attr("d", path);
    }

    function setCantons(ch) {
      //TODO if setMunicipalities => comment this block
      g.append("g")
          .attr("class", "feature canton")
        .selectAll("path")
          .data(topojson.feature(ch, ch.objects.cantons).features)
        .enter().append("path")
          .attr("fill", function(d) {
              return getColor(d, dataCantonMap)
            })
          .attr("d", path)
        .append("title")
          .text(function(d) { return d.id; });


      g.append("path")
        .datum(topojson.mesh(ch, ch.objects.cantons, function(a, b) { return a !== b; }))
        .attr("class", "feature canton-boundaries")
        .attr("d", path)

    }

    function getColor(d, map) {
      d.data = map.get(d.id)
      if (d.data >=50)
        return colorYes(d.data)
      else {
        return colorNo(d.data)
      }
    }


    // Print the abbreviation of each canton
    function setTextInCanton(cantons){
      g.selectAll("text")
          .data(cantons.features)
          .enter().append("text")
          .attr("transform", function(d) { return "translate(" + path.centroid(d) + ")"; })
          .attr("dy", ".35em")
          .text(function(d) { return d.properties.name; });
    }

    function setSlider() {
      d3.select('#slider').call(d3.slider()
            .axis(true)
            .min(min)
            .max(max)
            .step(1)
            .on("slide", function(evt, value) {
                d3.select('#sliderText').text(value);
                color =d3.scale.linear().domain([value,max]).range(["#ebfaeb","#33cc33"]);
                display(null,topo);
            })
          );
    }

    function setZoom() {
      var zoom = d3.behavior.zoom()
        .scaleExtent([1, 8])

        .on("zoom",function() {
            g.attr("transform", "translate(" + d3.event.translate + ")" + " scale(" + d3.event.scale + ")")
            g.selectAll("path")
                .attr("d", path.projection(null));

            var currentZoom = d3.event.scale;
            //console.log(currentZoom)
            if (currentZoom > 4) {
              //setMunicipalities(topo)
            }

        })
      svg
        .call(zoom)
        .call(zoom.event);
    }

    </script>

  </body>
</html>
